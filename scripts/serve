#!/usr/bin/env python3

from typing import Tuple, Dict
import socket
import select
from dotenv import dotenv_values
import sys
import os
import glob
import hashlib
from collections import defaultdict
from io import BytesIO
from threading import Thread, Lock, Event
from pathlib import Path
import struct

DYLIB_PORT = 8887
LOGS_PORT = 8889

files = list(map(Path, sys.argv[1:]))
if missing := [x for x in files if not x.exists()]:
    sys.stderr.write(f"ERROR: Some files are missing: {missing}\n")
    sys.stderr.flush()
    exit(1)
load_files = []
for file in files:
    if file.suffix in ['.dylib', '.m', '.mm']:
        load_files.append(file)

# NetworkLoader is always the first tweak — it needs sqlite3 and manages all others
_nl = Path("tweaks/NetworkLoader.m")
if _nl not in load_files:
    load_files.insert(0, _nl)


s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
try:
    s.connect(('1.1.1.1', 53))
    ip_addr = s.getsockname()[0]
    s.close()
except Exception:
    ip_addr = ""


class LogThread:
    def __init__(self):
        self._running = True
        self._buffer_map: Dict[Tuple[str, int], BytesIO] = defaultdict(BytesIO)
        self._thread = Thread(target=self._loop)
        self._lock = Lock()
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._min_recv_timeout = 0.1
        self._max_recv_timeout = 1
        self._recv_timeout_step = 0.1
        self._recv_timeout = self._min_recv_timeout
    
    def start(self):
        self._thread.start()
    
    def remove(self, addr):
        with self._lock:
            if buf := self._buffer_map.pop(addr, None):
                buf.seek(0)
                remaining = buf.read()
                if remaining:
                    sys.stdout.write(remaining.decode(errors='replace'))
                    if not remaining.endswith(b'\n'):
                        sys.stdout.write('\n')
                    sys.stdout.flush()

    def _loop(self):
        self._sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._sock.bind(('0.0.0.0', LOGS_PORT))
        self._sock.settimeout(self._recv_timeout)
        print(f"[*] LogThread started, listening for logs on port udp://{ip_addr}:{LOGS_PORT}...", flush=True)
        while self._running:
            try:
                data, addr = self._sock.recvfrom(65535)
                if data:
                    with self._lock:
                        buf = self._buffer_map[addr]
                        buf.write(data)
                        buf.seek(0)
                        content = buf.read()
                        last_nl = content.rfind(b'\n')
                        if last_nl >= 0:
                            sys.stdout.write(content[:last_nl + 1].decode(errors='replace'))
                            sys.stdout.flush()
                            remainder = content[last_nl + 1:]
                            buf.seek(0)
                            buf.truncate(0)
                            buf.write(remainder)
                    if self._running:
                        self._recv_timeout = max(self._min_recv_timeout, self._recv_timeout - self._recv_timeout_step)
                        self._sock.settimeout(self._recv_timeout)
            except socket.timeout:
                self._recv_timeout = min(self._max_recv_timeout, self._recv_timeout + self._recv_timeout_step)
                self._sock.settimeout(self._recv_timeout)
            except Exception:
                break

    def stop(self):
        print("[*] Stopping LogThread...", flush=True)
        self._running = False
        with self._lock:
            for buf in self._buffer_map.values():
                buf.seek(0)
                remaining = buf.read()
                if remaining:
                    sys.stdout.write(remaining.decode(errors='replace'))
                    if not remaining.endswith(b'\n'):
                        sys.stdout.write('\n')
            self._buffer_map.clear()
            sys.stdout.flush()
        print("[*] LogThread Joining...", flush=True)
        for addr in list(self._buffer_map.keys()):
            self._sock.sendto(b'BYE', addr)
        self._sock.close()
        self._thread.join()
        print("[*] LogThread stopped.", flush=True)



def recv_exact(conn, n):
    buf = b''
    while len(buf) < n:
        chunk = conn.recv(n - len(buf))
        if not chunk:
            raise ConnectionError("Connection closed")
        buf += chunk
    return buf


with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    t = LogThread()
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('0.0.0.0', DYLIB_PORT))
    s.listen(8)
    t.start()

    utils_dir = Path("lib/utils")
    max_mtime = max((f.stat().st_mtime for f in utils_dir.glob("*") if f.is_file()), default=0)

    print(f"[*] DYLIB Waiting for iPhone connections on tcp://{ip_addr}:{DYLIB_PORT}...")
    conns = []

    try:
        while True:
            conn, addr = s.accept()
            conns.append(conn)
            print(f"[*] Connected by {addr}")
            import subprocess

            # Build all dylibs and compute their hashes upfront
            failed = False
            file_infos = []  # list of (name_bytes, sha256_bytes, data_bytes)
            for file in load_files:
                if file.suffix in [".m", ".mm"]:
                    dylib_file = Path("build") / file.with_suffix('.dylib').name
                    dotenv_file = file.with_suffix('.env')
                    m_file = Path(file.resolve())
                    if (not dylib_file.exists()) or (dylib_file.stat().st_mtime < max(max_mtime, m_file.stat().st_mtime)):
                        print(f"[*] Building {dylib_file} from {m_file}...")
                        env_vars = dotenv_values(dotenv_file) if dotenv_file.exists() else {}
                        result = subprocess.run(["bash", "scripts/compile", str(m_file)], capture_output=True, text=True, env={**os.environ, **env_vars})
                        if result.returncode != 0:
                            print(f"ERROR: Failed to compile {m_file}:\n{result.stderr}")
                            failed = True
                            continue
                elif file.suffix == ".dylib":
                    dylib_file = file
                else:
                    continue
                with open(dylib_file, 'rb') as f:
                    data = f.read()
                #name = os.path.basename(dylib_file).encode()
                name = str(file.resolve()).encode()
                sha256 = hashlib.sha256(data).digest()
                mtime = int(dylib_file.stat().st_mtime)
                file_infos.append((name, sha256, mtime, data))
                print(f"[*] {dylib_file.name}: {len(data)} bytes, sha256={sha256.hex()[:16]}…")

            if failed:
                print("[*] Build failed for one or more files. Not sending anything to the iPhone.")
                conn.sendall(b"ERROR\n")
                conn.close()
                continue

            # Send READY + manifest (count, then name+sha256+mtime per file)
            conn.sendall(b"READY\n")
            conn.sendall(struct.pack('!I', len(file_infos)))
            for name, sha256, mtime, _ in file_infos:
                conn.sendall(struct.pack('<I', len(name)))
                conn.sendall(name)
                conn.sendall(sha256)          # 32 bytes
                conn.sendall(struct.pack('!Q', mtime))  # 8 bytes big-endian

            # Receive list of indices the iPhone still needs
            needed_count = struct.unpack('!I', recv_exact(conn, 4))[0]
            needed_indices = [struct.unpack('!I', recv_exact(conn, 4))[0] for _ in range(needed_count)]
            skipped = len(file_infos) - needed_count
            print(f"[*] iPhone needs {needed_count}/{len(file_infos)} files ({skipped} up-to-date)")
            if needed_indices:
                print(f"[*] Sending: {[file_infos[i][0].decode() for i in needed_indices]}")

            # Send only the requested files
            for idx in needed_indices:
                name, _, __, data = file_infos[idx]
                print(f"[*] Sending {name.decode()} ({len(data)} bytes)...")
                conn.sendall(struct.pack('!I', len(data)))
                conn.sendall(data)

            print("[*] All done. Keeping connection alive until you Ctrl+C.")
    except KeyboardInterrupt:
        print("[*] KeyboardInterrupt received, shutting down...")
        for conn in conns:
            try:
                conn.sendall(b"BYE\n")
                conn.close()
            except Exception:
                pass
    finally:
        t.stop()